name: Deploy to Staging

on:
  push:
    branches: [ develop ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if validation fails'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.11'
  SAM_VERSION: '1.100'
  AWS_REGION: 'eu-west-2'
  ENVIRONMENT: 'staging'

jobs:
  pre-deployment-validation:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.validation.outputs.should_deploy }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Set up SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        version: ${{ env.SAM_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov ruff mypy cfn-lint
        
    - name: Run validation checks
      id: validation
      run: |
        echo "Running pre-deployment validation..."
        
        # Run linting
        python -m ruff check src/ tests/ || exit 1
        
        # Run type checking
        python -m mypy src/ || exit 1
        
        # Validate SAM template
        sam validate --template-file infrastructure/template.yaml || exit 1
        
        # Run CFN Lint
        cfn-lint infrastructure/template.yaml || exit 1
        
        # Run critical tests
        python -m pytest tests/unit/ tests/integration/ -v --tb=short || exit 1
        
        echo "should_deploy=true" >> $GITHUB_OUTPUT
        echo "âœ… All validation checks passed"
        
  deploy-staging:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest
    needs: pre-deployment-validation
    if: needs.pre-deployment-validation.outputs.should_deploy == 'true' || github.event.inputs.force_deploy == 'true'
    environment: 
      name: staging
      url: https://${{ steps.deploy.outputs.api_endpoint }}
    permissions:
      contents: read
      id-token: write
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Set up SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        version: ${{ env.SAM_VERSION }}
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_STAGING_ROLE_ARN }}
        role-session-name: GitHubActions-Staging-Deploy
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Create deployment bucket if not exists
      run: |
        aws s3 ls s3://security-assistant-sam-deployments --region ${{ env.AWS_REGION }} > /dev/null 2>&1 || aws s3 mb s3://security-assistant-sam-deployments --region ${{ env.AWS_REGION }}
        
    - name: Build SAM application
      run: |
        sam build --template-file infrastructure/template.yaml --parallel
        
    - name: Create Lambda layer dependencies
      run: |
        mkdir -p layer/python
        pip install -r requirements.txt -t layer/python/
        # Remove dev dependencies that aren't needed in production
        find layer/python -name "*.pyc" -delete
        find layer/python -name "__pycache__" -type d -exec rm -rf {} + || true
        
    - name: Deploy to staging
      id: deploy
      run: |
        sam deploy \
          --config-env staging \
          --parameter-overrides \
            "Environment=${{ env.ENVIRONMENT }}" \
            "GeminiApiKey=${{ secrets.GEMINI_API_KEY }}" \
            "LambdaMemorySize=1024" \
            "LambdaTimeout=900" \
            "TrafficShiftingTimeoutInMinutes=5" \
            "TrafficShiftingPercentage=10" \
          --no-confirm-changeset \
          --no-fail-on-empty-changeset \
          --resolve-s3
          
        # Capture API endpoint
        API_ENDPOINT=$(aws cloudformation describe-stacks \
          --stack-name security-assistant-staging \
          --query 'Stacks[0].Outputs[?OutputKey==`ApiEndpoint`].OutputValue' \
          --output text)
        echo "api_endpoint=${API_ENDPOINT}" >> $GITHUB_OUTPUT
        echo "Deployment completed successfully!"
        echo "API Endpoint: ${API_ENDPOINT}"
        
    - name: Run post-deployment health checks
      run: |
        echo "Running post-deployment health checks..."
        API_ENDPOINT="${{ steps.deploy.outputs.api_endpoint }}"
        
        # Wait for deployment to stabilize
        sleep 30
        
        # Health check for API Gateway
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${API_ENDPOINT}/health" || echo "000")
        if [ "$HTTP_STATUS" = "200" ]; then
          echo "âœ… API Gateway health check passed"
        else
          echo "âŒ API Gateway health check failed (HTTP $HTTP_STATUS)"
          exit 1
        fi
        
        # Check CloudWatch metrics
        aws cloudwatch get-metric-statistics \
          --namespace AWS/Lambda \
          --metric-name Invocations \
          --dimensions Name=FunctionName,Value=security-assistant-api-staging \
          --start-time $(date -u -d '5 minutes ago' '+%Y-%m-%dT%H:%M:%S') \
          --end-time $(date -u '+%Y-%m-%dT%H:%M:%S') \
          --period 300 \
          --statistics Sum \
          --region ${{ env.AWS_REGION }} > /dev/null
        echo "âœ… CloudWatch metrics accessible"
        
        # Check DynamoDB table
        aws dynamodb describe-table \
          --table-name security-assistant-jobs-staging \
          --region ${{ env.AWS_REGION }} > /dev/null
        echo "âœ… DynamoDB table accessible"
        
        # Check S3 bucket
        aws s3 ls s3://security-assistant-files-staging/ > /dev/null
        echo "âœ… S3 bucket accessible"
        
        # Check SQS queue
        aws sqs get-queue-attributes \
          --queue-url $(aws sqs get-queue-url --queue-name security-assistant-processing-staging --query 'QueueUrl' --output text) \
          --region ${{ env.AWS_REGION }} > /dev/null
        echo "âœ… SQS queue accessible"
        
        echo "ðŸŽ‰ All health checks passed!"
        
    - name: Run smoke tests
      run: |
        echo "Running smoke tests against staging environment..."
        # Set environment variables for staging
        export API_BASE_URL="${{ steps.deploy.outputs.api_endpoint }}"
        export ENVIRONMENT="staging"
        export STORAGE_MODE="aws"
        
        # Run smoke test subset
        python -m pytest tests/integration/test_e2e.py::test_health_check -v
        echo "âœ… Smoke tests passed"
        
    - name: Notify deployment success
      if: success()
      run: |
        echo "ðŸš€ Staging deployment successful!"
        echo "Environment: ${{ env.ENVIRONMENT }}"
        echo "API Endpoint: ${{ steps.deploy.outputs.api_endpoint }}"
        echo "Deployment time: $(date)"
        
    - name: Notify deployment failure
      if: failure()
      run: |
        echo "âŒ Staging deployment failed!"
        echo "Please check the logs and resolve issues before retrying."
        
    - name: Rollback on failure
      if: failure()
      run: |
        echo "Attempting automatic rollback..."
        # Get previous successful deployment
        PREVIOUS_STACK=$(aws cloudformation describe-stack-events \
          --stack-name security-assistant-staging \
          --query 'StackEvents[?ResourceStatus==`UPDATE_COMPLETE`][0].PhysicalResourceId' \
          --output text 2>/dev/null || echo "")
          
        if [ -n "$PREVIOUS_STACK" ]; then
          echo "Rolling back to previous stable state..."
          aws cloudformation cancel-update-stack --stack-name security-assistant-staging || true
        else
          echo "No previous stable state found. Manual intervention required."
        fi