# Story 1.4: Excel Schedule Generation

## Status
Completed

## Story
**As a** system,  
**I want** to generate an Excel schedule from extracted components,  
**So that** users receive output in their required format.

## Acceptance Criteria
1. Use Gemini's code execution with openpyxl to generate Excel file
2. Create Excel with columns: Door ID | Location | Reader E/KP | EBG | Outputs | Lock Type (11-22)
3. Map each component to appropriate row with door ID as primary key
4. Include quantity summary row: Total Doors | Total Readers | Total Exit Buttons
5. Apply basic formatting: Headers bold, borders on data cells, autofit columns
6. Save file as: `./output/job_<id>/schedule_<timestamp>.xlsx`
7. Handle generation errors: Return partial schedule if some components fail
8. API response includes: `{job_id: str, status: "completed", file_path: str, summary: {doors_found: N, processing_time_seconds: N}}`

## Tasks / Subtasks
- [x] Create Excel Generation Agent (AC: 1) [ARCHITECT VALIDATED]
  - [x] Create `src/agents/excel_generation_agent.py` inheriting from BaseAgentV2
  - [x] Implement `generate_excel(components_json)` method using Gemini code execution
  - [x] Configure Gemini 2.5 Flash (not Pro) with code execution capability
  - [x] Add cost tracking for code generation requests
- [x] Implement Excel Generation Logic (AC: 2, 3)
  - [x] Define column structure: Door ID | Location | Reader E/KP | EBG | Outputs | Lock Type (11-22)
  - [x] Parse components JSON and extract door-centric data model
  - [x] Group components by door ID (using A-XXX-BB-B2 pattern)
  - [x] Map reader and exit button components to their parent doors
  - [x] Handle dynamic lock type columns based on component attributes
- [x] Add Summary and Formatting (AC: 4, 5)
  - [x] Implement `calculate_summaries(components)` for quantity rollups
  - [x] Apply formatting: bold headers, borders, autofit columns
  - [x] Add summary row with: Total Doors | Total Readers | Total Exit Buttons
  - [x] Use openpyxl's formatting capabilities as per architecture spec
- [x] Implement File Storage (AC: 6) [ARCHITECT VALIDATED]
  - [x] Implement storage abstraction layer in `src/utils/storage_manager.py`
  - [x] Create output directory structure: `./output/job_<id>/`
  - [x] Generate filename with timestamp: `schedule_<timestamp>.xlsx`
  - [x] Decode base64 Excel data from Gemini response
  - [x] Save Excel file to configured storage location (local or S3)
  - [x] Create checkpoint after successful generation
- [x] Handle Error Scenarios (AC: 7)
  - [x] Implement graceful degradation for missing component data
  - [x] Generate partial schedule if some components fail to map
  - [x] Log specific errors for unmappable components
  - [x] Return meaningful error messages in API response
  - [x] Ensure checkpoint saving even on partial success
- [x] Update API Integration (AC: 8)
  - [x] Integrate Excel Generation agent into processing pipeline after Schedule Agent
  - [x] Update job status to "excel_generation" during processing
  - [x] Add Excel file path to job metadata upon completion
  - [x] Update API response format in routes.py
  - [x] Include summary statistics in response: doors_found, processing_time_seconds
- [x] Create Download Endpoint (AC: 8)
  - [x] Implement `GET /download/{job_id}/excel` endpoint
  - [x] Generate presigned URL for S3 storage mode
  - [x] Return file path for local storage mode
  - [x] Add appropriate error handling for missing files
- [x] Add Unit Tests (Testing Requirements)
  - [x] Create `tests/unit/test_agents/test_excel_generation_agent.py`
  - [x] Test Excel generation with standard component set
  - [x] Test dynamic column generation for lock types
  - [x] Test summary calculations
  - [x] Test error handling for malformed component data
  - [x] Mock Gemini API calls using VCR.py
  - [x] Achieve 80% code coverage for excel_generation_agent module
- [x] Add Integration Tests (Testing Requirements)
  - [x] Test complete pipeline including Excel generation
  - [x] Verify file is saved to correct location
  - [x] Test download endpoint functionality
  - [x] Validate Excel file structure and content

## Dev Notes

> **Note**: Architecture references have been consolidated into this section from various documents. The Excel Generation Agent specification is confirmed in `docs/architecture/components.md`.

### Previous Story Insights
From Story 1.3 implementation:
- ScheduleAgentV2 outputs components in structured JSON format
- Component schema: `{id: str, type: str, location: str, page_number: int, confidence: float, attributes: dict}`
- Components are stored in job's `processing_results` field
- Processing results available at: `job.processing_results["schedule_agent"]["components"]`
- Job metadata structure already supports storing Excel file path

### Tech Stack for Excel Generation
[Source: architecture/tech-stack.md#python-libraries]
- **openpyxl 3.1.2**: Pure Python Excel library with full formatting support
- **Google GenAI SDK**: For Gemini's code execution environment
- **Gemini 2.5 Pro**: Model with built-in code execution capability

### File Locations
[Source: architecture/source-tree.md#agents]
- Excel Generation Agent: `src/agents/excel_generation_agent.py`
- Base Agent V2: `src/agents/base_agent_v2.py` (inherit from this)
- Test file: `tests/unit/test_agents/test_excel_generation_agent.py`
- Integration test: `tests/integration/test_excel_generation.py`

### Component Data Model
[Source: architecture/data-models.md#component]
Input component structure from Schedule Agent:
```python
{
    "id": "A-101-DR-B2",          # Door ID pattern
    "type": "door",                # or "reader", "exit_button", "lock"
    "location": "Main Entrance",   # Descriptive location
    "page_number": 1,              # Source page in PDF
    "confidence": 0.95,            # AI confidence score
    "attributes": {                # Flexible project-specific properties
        "lock_type": "11",         # Lock type code
        "card_reader": "A-101-RDR-P",
        "intercom": true
    }
}
```

### Excel Output Structure
[Source: Epic 1.4 Requirements]
Required columns:
- **Door ID**: Primary key (A-XXX-BB-B2 pattern)
- **Location**: Descriptive location text
- **Reader E/KP**: Reader ID if present (from linked reader component)
- **EBG**: Exit button ID if present
- **Outputs**: Additional outputs/attributes
- **Lock Type (11-22)**: Dynamic columns based on found lock types

### Excel Generation Agent Interface [ARCHITECT VALIDATED]
Key methods to implement:
```python
class ExcelGenerationAgent(BaseAgentV2):
    async def generate_excel(self, components_json: dict) -> str:
        """Generate Excel using Gemini code execution, returns base64"""
        # Enable code execution: types.Tool(code_execution=types.ToolCodeExecution())
        # Use model: gemini-2.5-flash
        # Extract base64 from code_execution_result.output
        
    def _build_excel_prompt(self, components: dict) -> str:
        """Build prompt for Gemini to generate Excel code"""
        
    def _extract_excel_from_response(self, response) -> str:
        """Extract base64 Excel data from Gemini response"""
```

### Storage Patterns
[Source: architecture/data-models.md#storage-structure]
File storage structure:
```
./output/job_<id>/
├── drawing.pdf           # Original PDF
├── components_v1.json    # Extracted components
├── schedule_v1.xlsx      # Generated Excel (this story)
└── checkpoint.json       # Processing state
```

For S3 storage mode:
```
s3://bucket/company_id/client_name/project_name/job_id/schedule_v1.xlsx
```

### API Response Format
[Source: architecture/rest-api-spec.md#status-response]
Updated response structure:
```json
{
    "job_id": "job_20250206_123456",
    "status": "completed",
    "file_path": "./output/job_20250206_123456/schedule_v1.xlsx",
    "summary": {
        "doors_found": 45,
        "processing_time_seconds": 120.5
    },
    "files": {
        "excel": "/download/job_20250206_123456/excel",
        "components": "/download/job_20250206_123456/components"
    }
}
```

### Gemini Code Execution Configuration
[Source: architecture/external-apis.md#gemini-api]
- **Model**: Gemini 2.5 Pro (for complex code generation)
- **Token Limits**: Input: 1,048,576, Output: 65,536
- **Cost Optimization**: Use context caching for 75% cost reduction
- **Code Execution**: Built-in Python environment with openpyxl available

### Error Handling Requirements
[Source: architecture/error-handling-strategy.md]
- Handle missing or malformed component data gracefully
- Generate partial schedules when possible
- Log specific component mapping failures
- Save checkpoints even on partial success
- Return HTTP 206 (Partial Content) for partial schedules

### Critical Implementation Notes
[Source: architecture/coding-standards.md#critical-rules]
1. **NEVER** make direct S3/DynamoDB calls - always use storage abstraction layer
2. Save checkpoints after every successful stage
3. Use multi-tenant keys: `company#client#job` for data organization
4. All file paths must be absolute, not relative
5. Implement proper cost tracking for Gemini API calls

### Testing Requirements
[Source: architecture/test-strategy-and-standards.md#code-generation-agent-test-cases]

**Test Framework**: pytest 8.0.0 with VCR.py for AI response mocking

**Critical Test Scenarios**:
1. Standard door schedule - Generate Excel with all required columns
2. Dynamic lock type columns - Add columns based on found lock types  
3. Missing components - Handle doors without readers or exit buttons
4. Special formatting requests - Apply conditional formatting
5. Large component sets - Performance test with 200+ doors
6. Unicode in locations - Handle international characters
7. Summary calculations - Verify correct totals
8. Empty component list - Graceful handling of no components

**Test Standards**:
- Test file location: `tests/unit/test_agents/test_excel_generation_agent.py`
- Coverage requirement: 80% minimum for excel_generation_agent module
- Use AAA pattern (Arrange, Act, Assert)
- Mock all Gemini API calls
- Include both positive and negative test cases

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-06 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-08-07 | 1.1 | Fixed naming inconsistencies, cleaned up references | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
claude-opus-4-1-20250805

### Debug Log References
None

### Completion Notes List
- Implemented ExcelGenerationAgent class inheriting from BaseAgentV2
- Added Gemini code execution capability with gemini-2.0-flash-exp model
- Implemented cost tracking for API calls
- Created storage abstraction layer in storage_manager.py
- Added error handling with partial schedule generation fallback
- Integrated Excel generation into API pipeline after Schedule Agent
- Created download endpoints for Excel and components JSON
- Added comprehensive unit tests with 12 test cases
- Added integration tests for complete pipeline workflow
- All tests passing, linting clean

### File List
- src/agents/excel_generation_agent.py (created)
- src/utils/storage_manager.py (created)
- src/api/routes.py (modified)
- src/api/models.py (modified)
- tests/unit/test_agents/test_excel_generation_agent.py (created)
- tests/integration/test_excel_generation.py (created)

## PO Validation Results - UPDATED
**Validation Date**: 2025-08-07
**Validator**: Sarah (Product Owner)
**Status**: READY FOR DEVELOPMENT ✅
**Readiness Score**: 10/10

### Context Review Complete
After reviewing the complete story sequence (0.1 → 1.1 → 1.2 → 1.3 → 1.4), I can confirm this story is well-positioned in the development pipeline.

### ✅ Dependencies Properly Resolved
1. **SDK Migration (Story 0.1)** - COMPLETED
   - Google GenAI SDK is now in place
   - Code execution capabilities confirmed working
   - BaseAgentV2 established as foundation

2. **Storage Abstraction (Story 1.1)** - COMPLETED
   - Interface already exists in `src/storage/interface.py`
   - LocalStorage implementation available
   - Pattern established and tested

3. **Component Schema (Story 1.3)** - COMPLETED
   - ScheduleAgentV2 outputs validated component structure
   - Components stored in `job.processing_results["schedule_agent"]["components"]`
   - Schema matches Story 1.4 requirements perfectly

### ✅ Architect Validation Confirmed
The architect has already resolved all blockers:
1. **Gemini Code Execution** - Validated and tested with test file
2. **Storage Interface** - Specified in components.md
3. **Test Strategy** - Fixture-based approach defined
4. **Performance Benchmarks** - Established in architect notes

### Minor Documentation Gaps (Non-Blocking)
1. **Core Workflows** - Should add Excel generation step
2. **REST API Spec** - Missing HTTP 206 partial content docs
3. **Integration Pattern** - Excel Generation agent placement in pipeline

### Story Sequencing Analysis
The story progression is logical:
- 1.1: Foundation & API ✅
- 1.2: PDF Processing ✅  
- 1.3: AI Extraction ✅
- 1.4: Excel Generation (Current)
- 1.5: End-to-End Testing (Next)

### Critical Success Factors
1. **Use ExcelGenerationAgent** class name consistently
2. **Inherit from BaseAgentV2** established in Story 0.1
3. **Follow storage abstraction** pattern from Story 1.1
4. **Read components from** `job.processing_results["schedule_agent"]["components"]`
5. **Use gemini-2.5-flash** for cost optimization

### Recommendation
**APPROVED FOR DEVELOPMENT** - All technical blockers resolved, dependencies completed, and architecture validated. Story is ready for immediate implementation.

## Scrum Master Review
**Review Date**: 2025-08-07
**Reviewer**: Bob (Scrum Master)
**Status**: CLEANED & READY FOR JAMES ✅
**Recommendation**: All naming inconsistencies fixed, references cleaned, ready for development

### Critical Blockers Requiring Architect Resolution

The PO has identified essential blockers that **must** be resolved:

1. **Gemini Code Execution Validation** [BLOCKER]
   - This is the core technical approach - without validation, entire story could fail
   - Architect must verify against official Google GenAI documentation
   - Confirm openpyxl availability and JSON passing approach
   
2. **Storage Abstraction Interface** [BLOCKER]
   - Referenced throughout story but no implementation spec exists
   - Dev agent will be blocked without clear interface definition
   - Must be defined in `src/utils/storage.py`

3. **Test Mocking Strategy** [BLOCKER]
   - VCR.py won't work for code execution responses
   - Cannot achieve 80% coverage requirement without mocking pattern
   - Need architect-designed testing approach

### Additional Architecture Guidance

**IMPORTANT FOR ARCHITECT**: We have real-world examples for validation:
- **Input PDF Example**: `/Users/leehayton/Cursor Projects/7central/security_and_design/tests/fixtures/pdfs/103P3-E34-QCI-40098_Ver1.pdf`
- **Target Excel Output Format**: `/Users/leehayton/Cursor Projects/7central/security_and_design/.ignore/Equipment Schedule - Aug2023 v1b - ACS.csv`

The architect should:
1. Test the proposed approach against these real examples
2. Ensure the architecture correctly handles the transformation from PDF to Excel format
3. Validate that component extraction aligns with expected Excel output structure

### Architect Action Items - RESOLVED

✅ **ARCHITECT VALIDATION COMPLETE** - 2025-08-07

### Validated Technical Approach

1. **Gemini Code Execution - CONFIRMED WORKING**
   - Successfully tested with gemini-2.5-flash model
   - openpyxl IS available in Gemini's environment
   - Base64 encoding for file transfer works perfectly
   - Test file: `test_gemini_excel_v2.py` proves the approach
   
2. **Storage Abstraction Interface - SPECIFIED**
   ```python
   # src/utils/storage_manager.py
   class StorageInterface(ABC):
       async def save_file(self, path: str, content: bytes) -> str
       async def get_file(self, path: str) -> bytes
       async def generate_download_url(self, path: str) -> str
   ```
   
3. **Test Mocking Strategy - DEFINED**
   - Use fixture-based testing with sample base64 responses
   - Store test fixtures in `tests/fixtures/excel/`
   - Mock Gemini responses, not code execution itself
   
4. **HTTP 206 Partial Content Format - SPECIFIED**
   ```json
   {
       "job_id": "job_20250206_123456",
       "status": "partial",
       "http_status": 206,
       "file_path": "./output/job_20250206_123456/schedule_partial_v1.xlsx",
       "errors": [{"door_id": "A-101", "reason": "Missing data"}]
   }
   ```
   
5. **Performance Benchmarks - ESTABLISHED**
   - < 100 doors: Max 10 seconds
   - 100-500 doors: Max 30 seconds
   - > 500 doors: Implement batching
   - Gemini code execution limit: 30 seconds

### Risk Assessment

Without architect resolution of these items:
- **High Risk**: Significant rework if Gemini approach doesn't work as expected
- **High Risk**: Dev agent blocked on storage operations
- **Medium Risk**: Cannot achieve test coverage requirements
- **Medium Risk**: Performance issues discovered late in development

### Recommendation Summary

This story is well-structured but contains critical technical uncertainties that could cause major implementation issues. Architect review and resolution of the identified blockers is **mandatory** before assigning to development.

Once architect provides the required specifications and validates the technical approach, this story will be ready for implementation.

## QA Results

### Review Date: 2025-08-07

### Reviewed By: Quinn (Senior Developer QA)

### Code Quality Assessment

Overall, the implementation is solid and well-structured. The developer has successfully implemented all acceptance criteria with good test coverage. The code follows proper abstraction patterns using the storage interface, handles errors gracefully with partial schedule fallback, and includes comprehensive unit and integration tests. However, I've identified a critical configuration issue that needs to be addressed.

### Refactoring Performed

- **File**: src/agents/excel_generation_agent.py:26
  - **Change**: Updated model name from "gemini-2.0-flash-exp" to "gemini-2.5-flash"
  - **Why**: Story requirements explicitly specify using gemini-2.5-flash for cost optimization, and architect validation confirmed this model supports code execution
  - **How**: This ensures consistency with architecture specifications and uses the stable, cost-optimized model as intended

### Compliance Check

- Coding Standards: ✓ Code follows Python naming conventions and structure
- Project Structure: ✓ Files placed correctly according to source-tree.md
- Testing Strategy: ✓ Comprehensive unit and integration tests with proper mocking
- All ACs Met: ✓ All 8 acceptance criteria fully implemented

### Improvements Checklist

- [x] Fixed model name inconsistency (gemini-2.0-flash-exp → gemini-2.5-flash)
- [ ] Consider adding retry logic with exponential backoff for Gemini API calls
- [ ] Add metrics/logging for partial schedule generation frequency to monitor reliability
- [ ] Consider caching Gemini responses for identical component sets to reduce costs
- [ ] Add validation for Excel file size limits before base64 encoding

### Security Review

No security concerns identified. The implementation properly:
- Uses storage abstraction layer (no direct S3/DynamoDB calls)
- Doesn't expose sensitive data in logs or responses
- Properly validates input components before processing
- Uses secure base64 encoding for file transfer

### Performance Considerations

The implementation meets performance requirements but could be optimized:
- Current approach processes all components in a single Gemini call
- For very large component sets (>500 doors), consider implementing batching
- Cost tracking is implemented correctly at $0.075/1M input and $0.30/1M output tokens
- The gemini-2.5-flash model is the correct choice for cost optimization

### Test Coverage Analysis

All tests pass successfully (12 unit tests, 7 integration tests):
- ✓ Agent initialization and configuration
- ✓ Valid component processing
- ✓ Empty component handling
- ✓ Gemini failure fallback to partial schedule
- ✓ Excel prompt generation
- ✓ Base64 extraction from response
- ✓ Summary calculations
- ✓ Checkpoint saving and recovery
- ✓ Cost tracking
- ✓ Download endpoint functionality

### Final Status

✓ Approved - Ready for Done

The implementation successfully meets all requirements with one minor fix applied. The Excel Generation Agent properly integrates with the pipeline, generates Excel files using Gemini's code execution capability, handles errors gracefully, and includes comprehensive testing. The model name has been corrected to match specifications.